/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.eventhubs.client

import com.microsoft.azure.eventhubs._
import org.apache.spark.eventhubs.utils.RetryUtils.{ retryJava, retryNotNull }
import org.apache.spark.{ SparkEnv, TaskContext }
import org.apache.spark.eventhubs.{ EventHubsConf, NameAndPartition, SequenceNumber }
import org.apache.spark.internal.Logging

import scala.concurrent.{ Await, Future }
import scala.concurrent.ExecutionContext.Implicits.global
import scala.collection.JavaConverters._
import scala.util.Success

private[spark] trait CachedReceiver {
  private[eventhubs] def receive(ehConf: EventHubsConf,
                                 nAndP: NameAndPartition,
                                 requestSeqNo: SequenceNumber,
                                 batchSize: Int): Iterator[EventData]
}

/**
 * An Event Hubs receiver instance that is cached on a Spark Executor to be
 * reused across batches. In Structured Streaming and Spark Streaming,
 * partitions are generated on the same executors across batches, so that
 * receivers can be cached are reused for maximum efficiency. Receiver caching
 * allows the underlying [[PartitionReceiver]]s to prefetch [[EventData]] from
 * the service before DataFrames or RDDs are generated by Spark.
 *
 * This class creates and maintains an AMQP link with the Event Hubs service.
 * On creation, an [[EventHubClient]] is borrowed from the [[ClientConnectionPool]].
 * Then a [[PartitionReceiver]] is created on top of the borrowed connection with the
 * [[NameAndPartition]].
 *
 * @param ehConf the [[EventHubsConf]] which contains the connection string used to connect to Event Hubs
 * @param nAndP the Event Hub name and partition that the receiver is connected to.
 */
private[client] class CachedEventHubsReceiver private (ehConf: EventHubsConf,
                                                       nAndP: NameAndPartition,
                                                       startSeqNo: SequenceNumber)
    extends Logging {

  import org.apache.spark.eventhubs._

  private lazy val client: EventHubClient = ClientConnectionPool.borrowClient(ehConf)

  private lazy val receiver: Future[PartitionReceiver] = {
    logInfo(s"creating receiver for Event Hub ${nAndP.ehName} on partition ${nAndP.partitionId}")
    val consumerGroup = ehConf.consumerGroup.getOrElse(DefaultConsumerGroup)
    val receiverOptions = new ReceiverOptions
    receiverOptions.setReceiverRuntimeMetricEnabled(false)
    receiverOptions.setIdentifier(
      s"spark-${SparkEnv.get.executorId}-${TaskContext.get.taskAttemptId}")
    val epochReceiver = retryJava(
      client.createEpochReceiver(consumerGroup,
                                 nAndP.partitionId.toString,
                                 EventPosition.fromSequenceNumber(startSeqNo).convert,
                                 DefaultEpoch,
                                 receiverOptions),
      "CachedReceiver creation."
    )
    epochReceiver.onComplete {
      case Success(x) => x.setPrefetchCount(DefaultPrefetchCount)
      case _          =>
    }
    epochReceiver
  }

  private def receiveOne: Future[Iterable[EventData]] = {
    receiver
      .flatMap { r =>
        retryNotNull(r.receive(1), "CachedReceiver receive call")
      }
      .map { _.asScala }
  }

  private def checkCursor(requestSeqNo: SequenceNumber): Future[Iterable[EventData]] = {
    val event = Await.result(receiveOne, InternalOperationTimeout)
    val receivedSeqNo = event.head.getSystemProperties.getSequenceNumber
    if (receivedSeqNo < requestSeqNo) {
      // If the receivedSeqNo is less than the requestSeqNo,
      // then some batches must have been completed on a
      // separate executor. This can happen when an executor
      // is added then removed.
      logWarning(s"$requestSeqNo did not match $receivedSeqNo. Advancing cursor for $nAndP")
      val advanceBy = requestSeqNo - receivedSeqNo - 1
      // Wait until the cursor advances to the correct spot.
      Await.result(Future.sequence(for { _ <- 0 until advanceBy.toInt } yield receiveOne),
                   InternalOperationTimeout)
      receiveOne
    } else if (receivedSeqNo > requestSeqNo) {
      throw new IllegalStateException(
        s"Request seqNo $requestSeqNo is less than the received seqNo $receivedSeqNo.")
    } else {
      Future { event }
    }
  }

  private def receive(requestSeqNo: SequenceNumber, batchSize: Int): Iterator[EventData] = {
    val first = checkCursor(requestSeqNo)
    val theRest = Future.sequence(for { _ <- 1 until batchSize } yield receiveOne)
    val combined = for {
      theRestRes <- theRest
      firstRes <- first
    } yield firstRes ++ theRestRes.flatten
    val sorted = combined.map { data =>
      data.toSeq
        .sortWith((e1, e2) =>
          e1.getSystemProperties.getSequenceNumber < e2.getSystemProperties.getSequenceNumber)
        .iterator
    }
    val newPrefetchCount = if (batchSize < PrefetchCountMinimum) PrefetchCountMinimum else batchSize
    receiver.onComplete {
      case Success(r) => r.setPrefetchCount(newPrefetchCount)
      case _          =>
    }
    Await.result(sorted, InternalOperationTimeout)
  }
}

/**
 * A companion object to the [[CachedEventHubsReceiver]]. This companion object
 * serves as a singleton which carries all the cached receivers on a given
 * Spark executor.
 */
private[spark] object CachedEventHubsReceiver extends CachedReceiver with Logging {

  type MutableMap[A, B] = scala.collection.mutable.HashMap[A, B]

  private[this] val receivers = new MutableMap[String, CachedEventHubsReceiver]()

  private def key(ehConf: EventHubsConf, nAndP: NameAndPartition): String = {
    (ehConf.connectionString + ehConf.consumerGroup + nAndP.partitionId).toLowerCase
  }

  private[eventhubs] override def receive(ehConf: EventHubsConf,
                                          nAndP: NameAndPartition,
                                          requestSeqNo: SequenceNumber,
                                          batchSize: Int): Iterator[EventData] = {
    logInfo(s"EventHubsCachedReceiver look up. For ${key(ehConf, nAndP)}")
    var receiver: CachedEventHubsReceiver = null
    receivers.synchronized {
      receiver = receivers.getOrElseUpdate(key(ehConf, nAndP), {
        CachedEventHubsReceiver(ehConf, nAndP, requestSeqNo)
      })
    }
    receiver.receive(requestSeqNo, batchSize)
  }

  def apply(ehConf: EventHubsConf,
            nAndP: NameAndPartition,
            startSeqNo: SequenceNumber): CachedEventHubsReceiver = {
    new CachedEventHubsReceiver(ehConf, nAndP, startSeqNo)
  }
}
